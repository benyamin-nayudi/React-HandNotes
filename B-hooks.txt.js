/*
/     هوک هارو فقط توی فانکشن کامپوننت ها میشه استفاده کرد و داخل کلس کامپوننت ها نمیشه چون که خودشون یه سری راه دارن واسه انجام دادن اینکار
$ نباید هوک هارو داخل ایف یا چیز دیگه ای بذاریم چون هوک ها تاپ لول هستن چرا؟ چون هوک ها باید دقیقا به همون اوردری که گذاشته شده ن کار کنن
$ حالا اگه مثلا یه دسته هوک به این صورت داشته باشیم
$ useState()
$ useState()
$ useState()
$ حالا اگه بیایم یه دونه برای مثال اولی یا اخری رو بذاریم داخل ایف 
$   if(something == someOtherThing){
    $    useState()
    $   }
    $ این هوکی که اینجاست ممکنه اول خونده بشه ممکنه نشه و ترتیب کلا خراب میشه...
    $ هر چند خود ریکت ارور رو میده ولی همیشه هوک ها تاپ لول هستن و نباید توی ایف سویج لوپ یا هرچیز دیگه ای قرار بگیرن
    
    &  در اینجا ما هوک یوز استیت رو داریم. این هوک دو مقدار برمیگردونه که معمولا برای گرفتن اون دو مقدار به صورت ارری از دیستراکچرینگ استفاده میکنیم. 
    & useState 
    & اینجا یه فانکشن داریم که دوتا دکمه داره و میخایم کاری کنیم که با زدن دکمه های منفی یا مثبت مقدار داخل اسپن عوض شه 
    
    
/    import React , {useState} from "react"
/function app(){
& یوز استیت یک ارری بهمون برمیگردونه که اولی مقدار اولیه ایه که ما بهش میدیم و هردفه کد خونده میشه. دومین مقدار یه فانکشنه که بهمون این اجازه رو میده که استیت خودمونو بتونیم اپدیت کنیم
& const [count , setCount] = useState(4)  
/   return(
/      <div>
/         <button>-</button>
/         <span>0</span>
/        <button>+</button>
/     </div>
/ )
    /}
    
$ +++++++++++
$ +++++++++++

  
/    import React , {useState} from "react"
/function app(){
/ const [count , setCount] = useState(4) 
/   return(
/      <div>
* پس ما اینجا به جای صفر به عنوان مقدار اولیه میتونیم از کاونت استفاده کنیم که مقدار اولیه شو خودمون برابر چهار  گذاشتیم
/         <button>-</button>
*         <span>  {count}  </span>
/        <button>+</button>

/     </div>
/ )
/}  

    $++++++++++++++
    $ حالا میایم یه فانکشن تعریف میکنیم به اسم دیکرمنت کاونت که میادش یه دونه از کاونت کم میکنه. به این صورت

/import React , {useState} from "react"
/function app(){
/ const [count , setCount] = useState(4) 

* این فانکشن میاد یه دونه از کاونتی که مقدار اولیه ش چهار بوده کم میکنه و اونو توی باتن منفی کال میکنیم
* function decrementCount(){
*    setCount(count - 1)
* }

/   return(
/      <div>
*         <button onClick ={decrementCount}>-</button>
/         <span>  {count}  </span>
/        <button>+</button>

/     </div>
/ )
    /}  

$++++++++++++++++++++
$++++++++++++++++++++
در حالت عادی عبارت 
setCount(count - 1)
میاد و مقدار کانت رو میگیره و یکی ازش کم میکنه ولی اگه ما این کد رو به این صورت توی فانکشنمون بنویسیم
& setCount(count - 1)
& setCount(count - 1)
اینا میان هم دیگه رو اوور رایت میکنن و در واقع اگه بخوایم که این کد دوبار اجرا بشه یعنی با هر رندر کردن دوتا کم بشه از کاونت این عمل به این صورتی که نوشته شد انجام پذیر نیست. 
واسه همین میتونیم به ست کاونت یه فانکشن بدیم و بهش بگیم اقا تو مقدار قبلی رو بگیر و یکی ازش کم کن اینطوری 
& setCount(   (prevCount)=> prevCount - 1    )

در این کد ست کاونت میاد مقدار قبلی کاونت رو هرچی بود میگیره و یکی ازش کم میکنه حالا اگه به این صورت بنویسمش
& setCount((prevCount)=> prevCount - 1)
& setCount((prevCount)=> prevCount - 1)
دومین مقدار ست کاونت میاد مقداری که از اولین ست کاونت گرفته (که یکی از کاونت کم کرده ) رو میگیره و دوباره یکی ازش کم میکنه. یعنی با هر رندر کردن ما دوبار ست کاونتمون اجرا میشه و دیگه اینا اوور رایت نمیشن چون  چیزی که ما دادیم بهش یک فانکشنه


/import React , {useState} from "react"
/function app(){
/ const [count , setCount] = useState(4) 

/ function decrementCount(){
//    setCount(count - 1)
* setCount((prevCount)=> prevCount - 1)
* setCount((prevCount)=> prevCount - 1)
/ }

/   return(
/      <div>
/         <button onClick ={decrementCount}> - </button>
/         <span>  {count}  </span>
/        <button>+</button>

/     </div>
/ )
    /}  

$++++++++++++++++++
$++++++++++++++++++

/ در نهایت فانکشن های اضافه و کم کردن باتن هارو مینویسیم 




/import React , {useState} from "react"
/function app(){
/ const [count , setCount] = useState(4) 

$ function decrementCount(){
$ setCount((prevCount)=>> prevCount - 1)
$ }

& function incrementCount(){
& setCount((prevCount)=> prevCount + 1)
& }

/   return(
/      <div>
*         <button onClick ={decrementCount}>-</button>
/         <span>  {count}  </span>
*        <button onClick ={incrementCount} >+</button>

/     </div>
/ )
    /}  


& +++++++++++++نکات+++++++++++++

$ ++++++++++نکته اول++++++++++++

/ در واقع برخلاف کلس کامپوننت ها ما هر دفعه که از صفحه رندر بگیریم این یوز استیت میاد و اون مقدار اولیه رو دوباره میخونه. یعنی ما که اونجا واسش مقدار اولیه چهار گذاشتیم رو هر دفعه کال میکنه که این امر تو کلس کامپوننت ها داخل کانستراکتور تعریف میشد. حالا بدبختی اینجاست که ما اگه یه کد ریاضی سنگینی داشته باشیم با هر بار رندر کردن صفحه سیستم کند میشه به خاطر همین یوز استیت دو حالت داره واسه پاس دادن پارامتر. یکی به صورت هارد کد و دادن عدد چهار مثلا، یکی هم پاس دادن یه فانکشن بهش

$   useState(  ()={}  )

خب حالا اگه از فانکشن یوز استیت استفاده کنیم دیگه این قضیه‌ی هربار کال کردن صورت نمیگیره، به این صورت که من اگه یه فانکشن تعریف کنم به این صورت

&  function countInitail(){
    &    console.log('salam jasem')
    &    return 4
    &  }
    و این فانکشن رو به صورت قدیمی به یوز استیت پاس بدم
    $ useState(countInitail())
    این با هر بار رندر شدنه اپپ دات جی اس، میاد و اون فانکشن مارو کال میکنه ولی اگه به صورت فانکشن بهش بدم این اتفاق نمیوفته
    
    / useState( () => countInitail()  )
    پس این قضیه فانکشن دادن واسه زمان هاییه که ما چیزای سنگینی دادیم به یوز استیت


    $ ++++++++++نکته دوم++++++++++++
    کلا قضیه رفتار یوز استیت با ابجکت ها یکمی فرق داره با کلس کامپوننت ها . اینجا ما یه ابجکت میدیم به یوزاستیت که علاوه بر مقدار اولیه کاونت یه کلمه دیگه هم همراهشه به اسم ثیم

    
/import React , {useState} from "react"
/function app(){
    * const [state , setState] = useState({count: 4 , theme: 'blue'}) 
    & ابجکت اولیه رو میذاریم توی استیت و بعدش کاونت و ثیم رو ازش درمیاریم
    & const count = state.count
    & const theme = state.theme
    $ اتفاقی که اینجا بعدا میوفته اینه که ما اگه فانکشن ست استیت رو به صورت قبل بنویسیم با یک کلیک مشاهده میکنیم که اون ثیم اور رایت میشه

/ function decrementCount(){
// setCount((prevCount)=> prevCount - 1)
*setState(prevState=> return {
    count: prevState.count - 1 
})
* تو این فانکشن ما اومدیم و یه فانکشن به ست استیت پاس دادیمم. این فانکشن میاد و استیت قبلی خودشو میگیره و میره برای کاونتش مقدار جدیدی ایجاد میکنه و اونو اپدیت میکنه . حالا مشکل اینجاست که ما اگه بیایم باتن رو بزنیم میبینیم که اون ثیمی که گذاشتیم میره به این دلیل که هوک ها میان کامل اور رایت میکنن هرچیزی که توی یوز استیت بودن رو که اول به عنوان مقدار اولیه بهشون دادیم پس انگار ما ثیمی نداریم دیگه بعد اور رایت کردن. واسه همین باید از اسپرید استفاده کنیم تا فقط اون مقداری که مخوایم رو اوور رایت کنیم و اون بقیه ش باقی بمونه و دلیت نشه به این صورت
*setState(prevState=> {
    ...prevState , count: prevState.count - 1 
})

$ راه دیگه این کار واسه اینکه از شر درست کردن این فانکشنا خلاص شیم اینه که کافیه دوتا هوک یوزاستیت تعریف کنیم که یکی میاد واسه کاونت مقدار میذاره و یکی واسه ثیم به این صورت
& const [count, setCount] = useState(4)
& const [theme, setTheme] = useState('blue')

/ }

/   return(
/      <div>
/         <button onClick ={decrementCount}> - </button>
*ما اون بالا در واقع کانت و ثیم رو دیستراکچر کردیم و الان میتونیم توی اسپن بذاریمشون
/         <span>  {count}  </span> 
*         <span>  {theme}  </span>
/        <button>+</button>

/     </div>
/ )
    /}

    */










